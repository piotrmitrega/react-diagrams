diff --git a/node_modules/pathfinding/src/finders/AStarFinder.js b/node_modules/pathfinding/src/finders/AStarFinder.js
index e9b2c42..c8e56c9 100644
--- a/node_modules/pathfinding/src/finders/AStarFinder.js
+++ b/node_modules/pathfinding/src/finders/AStarFinder.js
@@ -24,6 +24,8 @@ function AStarFinder(opt) {
     this.heuristic = opt.heuristic || Heuristic.manhattan;
     this.weight = opt.weight || 1;
     this.diagonalMovement = opt.diagonalMovement;
+		this.avoidStaircase = opt.avoidStaircase;
+		this.turnPenalty = opt.turnPenalty || 1;
 
     if (!this.diagonalMovement) {
         if (!this.allowDiagonal) {
@@ -59,9 +61,11 @@ AStarFinder.prototype.findPath = function(startX, startY, endX, endY, grid) {
         endNode = grid.getNodeAt(endX, endY),
         heuristic = this.heuristic,
         diagonalMovement = this.diagonalMovement,
+				avoidStaircase = this.avoidStaircase,
+				turnPenalty = this.turnPenalty,
         weight = this.weight,
         abs = Math.abs, SQRT2 = Math.SQRT2,
-        node, neighbors, neighbor, i, l, x, y, ng;
+				lastDirection, node, neighbors, neighbor, i, l, x, y, ng;
 
     // set the `g` and `f` value of the start node to be 0
     startNode.g = 0;
@@ -98,6 +102,14 @@ AStarFinder.prototype.findPath = function(startX, startY, endX, endY, grid) {
             // and calculate the next g score
             ng = node.g + ((x - node.x === 0 || y - node.y === 0) ? 1 : SQRT2);
 
+						// if we're avoiding staircasing, add penalties if the direction
+						// will change
+						if (avoidStaircase) {
+							lastDirection = node.parent === undefined? undefined : { x : node.x - node.parent.x, y : node.y - node.parent.y };
+							var turned = lastDirection === undefined? 0 : lastDirection.x !== x - node.x || lastDirection.y !== y - node.y;
+							ng += turnPenalty * turned;
+						}
+
             // check if the neighbor has not been inspected yet, or
             // can be reached with smaller cost from the current node
             if (!neighbor.opened || ng < neighbor.g) {
diff --git a/node_modules/pathfinding/src/finders/BiAStarFinder.js b/node_modules/pathfinding/src/finders/BiAStarFinder.js
index c20e22c..9492475 100644
--- a/node_modules/pathfinding/src/finders/BiAStarFinder.js
+++ b/node_modules/pathfinding/src/finders/BiAStarFinder.js
@@ -25,6 +25,8 @@ function BiAStarFinder(opt) {
     this.diagonalMovement = opt.diagonalMovement;
     this.heuristic = opt.heuristic || Heuristic.manhattan;
     this.weight = opt.weight || 1;
+		this.avoidStaircase = opt.avoidStaircase;
+		this.turnPenalty = opt.turnPenalty || 1;
 
     if (!this.diagonalMovement) {
         if (!this.allowDiagonal) {
@@ -62,9 +64,11 @@ BiAStarFinder.prototype.findPath = function(startX, startY, endX, endY, grid) {
         endNode = grid.getNodeAt(endX, endY),
         heuristic = this.heuristic,
         diagonalMovement = this.diagonalMovement,
-        weight = this.weight,
+				avoidStaircase = this.avoidStaircase,
+				turnPenalty = this.turnPenalty,
+				weight = this.weight,
         abs = Math.abs, SQRT2 = Math.SQRT2,
-        node, neighbors, neighbor, i, l, x, y, ng,
+				lastDirection, node, neighbors, neighbor, i, l, x, y, ng;
         BY_START = 1, BY_END = 2;
 
     // set the `g` and `f` value of the start node to be 0
@@ -107,6 +111,14 @@ BiAStarFinder.prototype.findPath = function(startX, startY, endX, endY, grid) {
             // and calculate the next g score
             ng = node.g + ((x - node.x === 0 || y - node.y === 0) ? 1 : SQRT2);
 
+						// if we're avoiding staircasing, add penalties if the direction
+						// will change
+						if (avoidStaircase) {
+							lastDirection = node.parent === undefined? undefined : { x : node.x - node.parent.x, y : node.y - node.parent.y };
+							var turned = lastDirection === undefined? 0 : lastDirection.x !== x - node.x || lastDirection.y !== y - node.y;
+							ng += turnPenalty * turned;
+						}
+
             // check if the neighbor has not been inspected yet, or
             // can be reached with smaller cost from the current node
             if (!neighbor.opened || ng < neighbor.g) {
@@ -152,6 +164,14 @@ BiAStarFinder.prototype.findPath = function(startX, startY, endX, endY, grid) {
             // and calculate the next g score
             ng = node.g + ((x - node.x === 0 || y - node.y === 0) ? 1 : SQRT2);
 
+						// if we're avoiding staircasing, add penalties if the direction
+						// will change
+						if (avoidStaircase) {
+							lastDirection = node.parent === undefined? undefined : { x : node.x - node.parent.x, y : node.y - node.parent.y };
+							var turned = lastDirection === undefined? 0 : lastDirection.x !== x - node.x || lastDirection.y !== y - node.y;
+							ng += turnPenalty * turned;
+						}
+
             // check if the neighbor has not been inspected yet, or
             // can be reached with smaller cost from the current node
             if (!neighbor.opened || ng < neighbor.g) {
